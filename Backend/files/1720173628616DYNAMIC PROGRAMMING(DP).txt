

DYNAMIC
PROGRAMMING(DP)
ItismethodusedinProgrammingandMathematicsto
SolveComplexComputationalProblemsFastly,bybreakingthemdown
intosmallersubProblems.
ByBreakingDowntheProblemsintosmallersubProblems,Westorethe
resultofthesesub-ProblemsintospecificDataStructuresdependingOn
Use-caseoftheProblemandWeavoidUnnecessaryandRedundant
ComputationsandRetrievetheAlreadyComputedInformationFromData
StructuresandUsetoSolvetheProblems.
●It’sBasicallyTheOptimizedTechniqueOverRecursioni.e..InSome
ProblemswhilewesolvethemTheirexistsMultipleOverlappingSub
Problems,andweComputeMultipleTimes.Soforthemifwe
computeOnceIt’senoughandstoretheresultinDataStructureand
RetrieveThemWhenNeeded.TheAboveprocessdecreasesThe
Computing(TimeComplexity)andsolveproblemfastly.
●
DpProblemsInvolveRecursivepatternswheresolutionisbuildup
fromtheverybasecasetoallthewayuptothetop.Thereforsit’s
prettyintensiveintrmsofTimeandspacecomplexity.ButThereare
fewtechniqueswhichareusedtooptimizethesolutionsothe
algorithmtakeslesstimeandmemorytoexecute.MostOfones
Themare:
1)Memoization.
2)Tabulation.
ByusingDPwecansolvecomplexproblemsfasterandsomeofthe
standardalgorithmsinclude:

Bellman-Fordalgorithmforsingle-sourceshortestpath,Floyd
warshallalgorithmforallpairsshortestalgorithm,0-1knapsackProblem
etc...
●Recursion:
Lotofsub-problemsarerepetitivebutsolvedagain
becauseofthenatureoftherecursivealgorithms.
Forexample1):Letsconsiderthefibonoccisequence
0,1,1,2,3,5,8,13,21,..etc...Findfib(n)??
Solution:
WeKnowthatFib(n)=Fib(n-1)+Fib(n-2).
Letuslookatthecodeforsolvingaboveproblem.
Fib(n){
if(n<=1)returnn;
returnFib(n-1)+Fib(n-2);
cout<<Fib(5)<<endl;

Fromabovetreediagramfib(7)iscalculatedbyFib(6)
+fib(5)andfib(6)byfib(4)andFib(3)andthiscyclegoeson...
TimeComplexity:O(2^n)aseverycalltakesTwocallsforeach
one.
Spacecomplexity:O(n)forcallstack.
Memoization(Top-Down):Itistechniqueinwhichwestore
theresultsandusethemwhenrequireinsteadofcomputing
againtoreducetimecomplexity.
#include<bits/stdc++.h>
Usingnamespacestd;
unordered-map<int,int>memo;
intfib(n){
if(memo.find(n)!=memo.end())returnmemo[n];
if(n<=1)returnn;
memo[n]=fib(n-1)+fib(n-2);
returnmemo[n];

}
Intmain(){
intn=7;
cout<<fib(n)<<endl;
}
Herememo[2],memo[3],memo[4],memo[5]...arecalculated
onceandstoredforlateruseanditdoesfaster.
Timecomplexity:O(n).
Spacecomplexity:O(n).
TABULATION(Bottom-Up)(Iterative):
Usingthistechnique,adynamicprogrammingproblemis
solvediterativelyinsteadofrecursion.Basically,afterdeterminingthe
relationbetweenmainproblemanditssub-problems,westartfrom
theverybasecaseandsolveuptillthemainproblem.Theresultsare
storedinadatastructuresuitabletosolvetheproblem.
Code:
intFib(n){
vector<int>vec(n+1,0);

Fib[0]=0;
Fib[1]=1;
for(inti=2;i<=n;i++){
Fib[i]=Fib[i-1]+Fib[i-2];
}returnFib[n];
}intmain(){
cout<<Fib(7)<<endl;
}
Herewestoretheresultindatastructure,westoretheresult
consecutivelyandreturntheresult.
HereinBothMemoizationandtabulationwestoretheresults
forfurtheruseandinmemoizationweuseRecursionandin
tabulationIterativeapproachisused.
Example2:
Givenasetofnonnegativeintegersandavaluesum,determineif
theirisasubsetofgivensetwhosesumisgivensum.
Input:set[]={3,34,4,12,5,2}
Sum=9,
Output:True;
2)set[]={3,34,4,12,5,2};sum=30;
Output:False;
M-1:Recursion:
Forrecursiveapproachwehavetwocases:
1)Considerlastelementandnowhwhavetotalsum=sum-last
andtotalelements=totalelement-1

2)Leavelastelementandtotalelements=totalelement-1and
sum=sum
isSubset(set,n,sum)=
isSubset(set,n-1,sum)||
isSubset(set,n-1,sum-set[n-1])
Basecase:
isSubsetSum(set,n,sum)=false,ifsum>0andn==0
isSubsetSum(set,n,sum)=true,ifsum==0
TreesimulationofAboveApproach:
(4,9)
{True}
/\
(3,6)(3,9)
/\/\
(2,2)(2,6)(2,5)(2,9)
{True}
/\
(1,-3)(1,2)
{False}{True}
/\
(0,0)(0,2)
{True}{False}
RecursiveCode:
#include<iostream>
usingnamespacestd;
boolisSubsetSum(intset[],intn,intsum)
{
if(sum==0)//ifsumiszero
returntrue;
if(n==0)

returnfalse;
//Iflastelementisgreaterthansum,
//thenignoreit
if(set[n-1]>sum)
returnisSubsetSum(set,n-1,sum);
returnisSubsetSum(set,n-1,sum)
||isSubsetSum(set,n-1,sum-set[n-1]);//excludelastor
includelastelement
}
intmain()
{
intset[]={3,34,4,12,5,2};
intsum=9;
intn=sizeof(set)/sizeof(set[0]);
if(isSubsetSum(set,n,sum)==true)
cout<<"Foundasubsetwithgivensum";
else
cout<<"Nosubsetwithgivensum";
return0;
}
OUTPUT:FoundasubsetofGivensum
Byrecursionwecalculateifsubsetispresentornotinthesetby
eliminatingoneelementeachoraddingittosubset.
TimeComplexity:O(2^n).
SpaceComplexity:O(n)
ByMethod2:
TosolvetheprobleminPseudo-polynomialtimeusethe
Dynamicprogramming.

Sowewillcreatea2Darrayofsize(arr.size()+1)*(target+1)of
typeboolean.ThestateDP[i][j]willbetrueifthereexistsasubsetof
elementsfromA[0....i]withsumvalue='j'.Theapproachforthe
problemis:
if(A[i-1]>j)
DP[i][j]=DP[i-1][j]
else
DP[i][j]=DP[i-1][j]ORDP[i-1][j-A[i-1]]
Thismeansthatifcurrentelementhasvaluegreaterthan
'currentsumvalue'wewillcopytheanswerforprevious
cases
Andifthecurrentsumvalueisgreaterthanthe'ith'
elementwewillseeifanyofpreviousstateshavealready
experiencedthesum='j'ORanypreviousstates
experiencedavalue'j-A[i]'whichwillsolveourpurpose.
Thebelowsimulationwillclarifytheaboveapproach:
Ex:1)
set[]={3,4,5,2}
target=6
0123456
0TFFFFFF
3TFFTFFF
4TFFTTFF
5TFFTTTF
2TFTTTTT
Code:

boolisSubsetSum(intset[],intn,intsum)
{
//Thevalueofsubset[i][j]willbetrueif
//thereisasubsetofset[0..j-1]withsum
//equaltoi
boolsubset[n+1][sum+1];
//Ifsumis0,thenansweristrue
for(inti=0;i<=n;i++)
subset[i][0]=true;
//Ifsumisnot0andsetisempty,
//thenanswerisfalse
for(inti=1;i<=sum;i++)
subset[0][i]=false;
//Fillthesubsettableinbottomupmanner
for(inti=1;i<=n;i++){
for(intj=1;j<=sum;j++){
if(j<set[i-1])
subset[i][j]=subset[i-1][j];
if(j>=set[i-1])
subset[i][j]=subset[i-1][j]
||subset[i-1][j-set[i-1]];
}
}
for(inti=0;i<=n;i++)
{
for(intj=0;j<=sum;j++)
printf("%4d",subset[i][j]);
cout<<"\n";
}

returnsubset[n][sum];
}
intmain()
{
intset[]={3,34,4,12,5,2};
intsum=9;
intn=sizeof(set)/sizeof(set[0]);
if(isSubsetSum(set,n,sum)==true)
cout<<"Foundasubsetwithgivensum";
else
cout<<"Nosubsetwithgivensum";
return0;
}
Output:
Foundasubsetwithgivensum
ComplexityAnalysis:
TimeComplexity:O(sum*n),wheresumisthe'target
sum'and'n'isthesizeofarray.
AuxiliarySpace:O(sum*n),asthesizeof2-Darrayis
sum*n.+O(n)forrecursivestackspace
Approach3):
MemoizationTechniqueforfindingSubsetSum:
Inthismethod,wealsofollowtherecursiveapproachbutInthis
method,weuseanother2-Dmatrixinwefirstinitializewith-1
oranynegativevalue.
Inthismethod,weavoidthefewoftherecursivecallwhichis
repeateditselfthat'swhyweuse2-Dmatrix.Inthismatrixwe
storethevalueofthepreviouscallvalue.

Code:
inttab[2000][2000];
intsubsetSum(inta[],intn,intsum)
{
if(sum==0)
return1;
if(n<=0)
return0;
Ifthevalueisnot-1itmeansit
alreadycallthefunction
withthesamevalue.
itwillsaveourfromtherepetition.
if(tab[n-1][sum]!=-1)
returntab[n-1][sum];
ifthevalueofa[n-1]is
greaterthanthesum.
wecallforthenextvalue
if(a[n-1]>sum)
returntab[n-1][sum]=subsetSum(a,n-1,sum);
else
{
Herewedotwocallsbecausewe
don'tknowwhichvalueis
full-fillourcriteria
that'swhywedoingtwocalls
returntab[n-1][sum]=subsetSum(a,n-1,sum)||
subsetSum(a,n-1,sum-a[n-1]);
}

}
intmain()
{
//Storingthevalue-1tothematrix
memset(tab,-1,sizeof(tab));
intn=5;
inta[]={1,5,3,7,4};
intsum=12;
if(subsetSum(a,n,sum))
{
cout<<"YES"<<endl;
}
else
cout<<"NO"<<endl;
}
Output
YES
ComplexityAnalysis:
TimeComplexity:O(sum*n),wheresumisthe'target
sum'and'n'isthesizeofarray.
AuxiliarySpace:O(sum*n)+O(n)->O(sum*n)=the
sizeof2-Darrayissum*nandO(n)=auxiliarystack
space.
QUIZ:
AttempttheQUIZandcheckwhetheryouhave
understoodtheConceptorNot

1)Whichofthestandardalgorithmisnotdynamic
programmingbased?
1)Bellman-Fordalgorithmforsingle-source
shortestpath.
2)Floydwarshallalgorithmforallpairsshortest
algorithm.
3)0-1knapsackProblem.
4)4)Prim’sMinimumspanningtree.
Answer:
4)ItisGreedyAlgorithm,
remainingallotherareDynamicprogrammingbased.
2)WeuseDynamicProgrammingApproachWhen?
1)WeneedanOptimalsolution.
2)Thesolutionhasoptimalsubstructure.
3)Thegivenproblemcanbereducedtoeasyone.
4)Fasterthangreedy.
Answer:
WeuseDpwhensolutionhasanoptimal
substructure.
3)WhichofthefollowingisnotancharacteristicofDP?
1)Memoizationwhichinvolvesstoringresultsofexpensive
functioncallsandreusingthem.
2)Breakingaproblemintosmallersubproblems.
3)Solvingprobleminsequentialproblem
4)Dpcanbeusedfortheproblemswheresolutionhas
optimalsubstructure.
Answer:

Option1)InDpwebreakdowntheproblem
intosmallersubproblemstosolveitifweseethe
problemissolvedhereitselfreturnsavedanswer
elseifithasn;tbeensolvedsolveitandsavethe
returnanswerThisisusuallyeasytothinkandvery
intuitiveanditisMemoization.
2)ItisbighintforsolvingDPproblemswhere
webreakdownproblemsintosmallerproblemsand
solvethem.
3)Dpcanneverbesolvedbysequential
process.
4)Dpcanbeusedfortheproblemswhereithas
optimalsubstructure.
4)whatismemoizationincontextofDP?
1)ATechniquetowritememoryefficientprogram.
2)Awaytoavoidtosolvingsubproblemsand
storingresultsandreusing.
3)Aprocessofconvertingrecursivealgorithmsto
iterative
4)Amethodofanalyzingthetimecomplexityof
algorithms.
Explanation:Memoizationisfundamental
techniqueinDPwhereestorethecomputed
resultindatastructureandnextwedon’t
computeresultinsteadweusethesameresult
anddecreaseexecutiontime.
5)Considerasequenceaf00definedas:
Foo(0)=1
Foo(1)=1
Foo(n)=10*Foo(n-1)+100

Foo(n-2)forn>=2
Thenwhatshallbethesetofvaluesforthesequence
F00?
1)1,110,12002)1,110,600,1200
3)1,2,55,66,774)1,55,23,445
Answer:
Foo(0)=1andFoo(1)=1
Foo(n)=10*Foo(n-1)+100
Foo(2)=10*Foo(1)+100
F(2)=110
Similarly
Foo(3)=F(2)*10+100
Foo(3)=1200
Thesequencewillbe1,110,1200.
Sooption1iscorrect.

HereisThevideoLinktoUnderstandBasicsAboutDynamicProgramming(Dp):
Dynamic Programming | Introduction
ReferenceLinktounderstandMoreAbouttheConcept:
DynamicProgrammingorDP-GeeksforGeeks